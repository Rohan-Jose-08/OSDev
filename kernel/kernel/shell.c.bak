#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <kernel/tty.h>
#include <kernel/keyboard.h>

#define MAX_COMMAND_LENGTH 256

// VGA colors from vga.h
enum vga_color {
	VGA_COLOR_BLACK = 0,
	VGA_COLOR_BLUE = 1,
	VGA_COLOR_GREEN = 2,
	VGA_COLOR_CYAN = 3,
	VGA_COLOR_RED = 4,
	VGA_COLOR_MAGENTA = 5,
	VGA_COLOR_BROWN = 6,
	VGA_COLOR_LIGHT_GREY = 7,
	VGA_COLOR_DARK_GREY = 8,
	VGA_COLOR_LIGHT_BLUE = 9,
	VGA_COLOR_LIGHT_GREEN = 10,
	VGA_COLOR_LIGHT_CYAN = 11,
	VGA_COLOR_LIGHT_RED = 12,
	VGA_COLOR_LIGHT_MAGENTA = 13,
	VGA_COLOR_LIGHT_BROWN = 14,
	VGA_COLOR_WHITE = 15,
};

static inline unsigned char vga_entry_color(enum vga_color fg, enum vga_color bg) {
	return fg | bg << 4;
}

// Command counter
static unsigned int command_count = 0;

// Forward declarations
static void output_prompt(void);
static void input_line(char* buffer, size_t max_length);
static void execute_command(const char* command);
static void command_help(void);
static void command_clear(void);
static void command_echo(const char* args);
static void command_about(void);
static void command_color(const char* args);
static void command_colors(void);
static void command_calc(const char* args);
static void command_sysinfo(void);
static void command_banner(void);

// String comparison function (since we don't have strcmp yet)
static int strcmp_local(const char* s1, const char* s2) {
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }
    return *(unsigned char*)s1 - *(unsigned char*)s2;
}

// String copy function
static void strcpy_local(char* dest, const char* src) {
    while (*src) {
        *dest++ = *src++;
    }
    *dest = '\0';
}

// Check if string starts with prefix
static bool starts_with(const char* str, const char* prefix) {
    while (*prefix) {
        if (*str++ != *prefix++) {
            return false;
        }
    }
    return true;
}

void shell_init(void) {
    char command[MAX_COMMAND_LENGTH];
    
	command_banner();
	
	while (true) {
		output_prompt();
		input_line(command, MAX_COMMAND_LENGTH);
		
		if (strlen(command) > 0) {
			command_count++;
			execute_command(command);
		}
	}
}

static void output_prompt(void) {
    printf("myos> ");
}

static void input_line(char* buffer, size_t max_length) {
    size_t pos = 0;
    
    while (true) {
        // Wait for keyboard input
        while (!keyboard_has_input()) {
            // Busy wait - in a real OS, you'd want to halt or yield here
            __asm__ volatile ("hlt");
        }
        
        char c = keyboard_getchar();
        
        if (c == '\n') {
            // End of line
            buffer[pos] = '\0';
            printf("\n");
            return;
        } else if (c == '\b') {
            // Backspace
            if (pos > 0) {
                pos--;
                // Move cursor back, print space, move back again
                printf("\b \b");
            }
        } else if (c >= 32 && c < 127) {
            // Printable character
            if (pos < max_length - 1) {
                buffer[pos++] = c;
                // Character already echoed by keyboard handler
            }
        }
    }
}

static void execute_command(const char* command) {
    // Skip leading spaces
    while (*command == ' ') command++;
    
    if (strcmp_local(command, "help") == 0) {
        command_help();
    } else if (strcmp_local(command, "clear") == 0) {
        command_clear();
    } else if (strcmp_local(command, "about") == 0) {
        command_about();
	} else if (strcmp_local(command, "colors") == 0) {
		command_colors();
	} else if (strcmp_local(command, "sysinfo") == 0) {
		command_sysinfo();
	} else if (strcmp_local(command, "banner") == 0) {
		command_banner();
	} else if (starts_with(command, "echo ")) {
		command_echo(command + 5);
	} else if (starts_with(command, "color ")) {
		command_color(command + 6);
	} else if (starts_with(command, "calc ")) {
		command_calc(command + 5);
    printf("  help   - Display this help message\n");
    printf("  clear  - Clear the screen\n");
    printf("  echo   - Echo text to the screen\n");
    printf("  about  - Display information about this OS\n");
    printf("\n");
}

static void command_clear(void) {
    terminal_initialize();
}

static void command_echo(const char* args) {
    // Skip leading spaces
    while (*args == ' ') args++;
    
    if (*args) {
        printf("%s\n", args);
    } else {
        printf("\n");
    }
}

static void command_about(void) {
    printf("\n");
    printf("MyOS - A Simple Operating System\n");
    printf("================================\n");
    printf("Version: 1.0\n");
    printf("Architecture: i386\n");
    printf("\n");
    printf("Features:\n");
    printf("  - Custom kernel with interrupt handling\n");
    printf("  - VGA text mode display\n");
    printf("  - Keyboard input support\n");
    printf("  - Basic shell with command processing\n");
    printf("\n");
}